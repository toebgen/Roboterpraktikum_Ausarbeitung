% #############################################################################
%															Bahnplanung und Steuerung
% #############################################################################
\chapter{Bahnplanung und Steuerung}
\label{bahnplanung_steuerung_cha}

% ********************************************************************************
% 										Aufgabenstellung
% ********************************************************************************
\section{Aufgabenstellung}
\label{bahnplanung_aufgabenstellung_sec}
\authorsection{\editoroier}

Was die Aufgabestellung für die Bahnplanung und Steuerung betrifft, so kann man das in Abstraktionsschichten einteilen:
LowLevel-Ansteuerung, Inverse Kinematik, Bahnplanung und Kollisionsvermeidung.
Außerdem sollte man das alles auch Simulieren können.

Als Ausgangssituation hatte man die Grundlagen der Odete für die LowLevel-Ansteurung.
Sonst waren inverse Kinematik, Bahnplanung/Steuerung, Kollisionsvermeidung und Simulationsumgebung nicht vorhanden.

Nach dem Bottom-Up Prinzip hat man zunächst, die LowLevel-Ansteuerung von der Odete angepasst und mittels Simulation getestet.
Da die Simulationsumgebung für die SegwayOmni Plattform nicht vorhanden war, musste diese auch eingerichtet werden.

Das \textit{DriveAlongPath} Modul, welches sich mit der inverse Kinematik beschäftigt, dient um aus Koordinaten die nötige Geschwindigkeiten für \textit{OmniDrive} zu berechnen.
Falls es sich bspw. um ein Industrieroboter handeln würde, dann würde die inverse Kinematik die nötige Gelenkwinkeleinstellungen berechnen, um mit dem Greifer eine neue Position zu erreichen.
Danach würde die inverse Dynamik die entsprechende Motor-Kräfte und Momente berechnen.

Die Bahnplanung berechnet Trajektoriepunkte auf Basis der Mensch-Position und Geschwindigkeit, welche von der Kinect-Kamera geliefert werden.
Außerdem werden hier diverse Transformationen von Welt zu Roboter bzw. Bild-Koordinaten und zurück gemacht.
Nebenbei, wird der Pfad gespeichert damit der Roboter es später alleine abfahren kann.

Zum Schluß wird eine ständige Überprüfung der geplante Trajektorie gemacht, um Kollisionen zu vermeiden.
Um Hindernisse zu umfahren, werden der A*-Algorithmus und ein Anti-Gravitationsfeld eingesetzt.
Letzteres wirkt, dass es \glqq teuer\grqq \space ist in der nähe von Hindernisse zu fahren.



% ********************************************************************************
% 										Grundlagen Bahnplanung
% ********************************************************************************
\section{Grundlagen Bahnplanung}
\label{bahnplanung_grundlagen_sec}
\authorsection{\editoroier}

\todo[inline]{Oier: Schreiben}


% ********************************************************************************
% 										Umsetzung
% ********************************************************************************
\section{Umsetzung}
\label{bahnplanung_umsetzung_sec}


% -----------------------------------------------------------------------------
%													LowLevel-Ansteuerung
\subsection{LowLevel-Ansteuerung}
\label{bahnplanung_lowlevel_subsec}
\authorsection{\editoroier}

\todo[inline]{Oier: Schreiben}

% evtl. auch so ein Diagramm wie Abb. 4.4 von WS10/11?
%		bzw. Abb. 2.3 von WS09/10


% -----------------------------------------------------------------------------
%													Inverse Kinematik
\subsection{Inverse Kinematik}
\label{inverse_kinematik_subsec}
\authorsection{\editorjulian}

\todo[inline]{Julian: Schreiben}


% -----------------------------------------------------------------------------
%													Bahnplanung
\subsection{Bahnplanung}
\label{bahnplanung_subsec}
\authorsection{\editortobias}
\todo[inline]{Tobi: Schreiben}


\begin{itemize}
	\item Kurzer Grobüberblick über die Behaviours-Gruppe, hier werden Bahnplanungs-Aufgaben bearbeitet\todoprivate{ref zu behaviours-Bild}
	\begin{itemize}
		\item Berechnung von Trajektorien-Punkten auf Basis der Mensch-Position und Geschwindigkeit (Kinect)
		\item Schätzung der zukünftigen Position des Menschen
		\item Transformation von Welt- in Roboter- bzw. Bildkoordinaten und zurück\todoprivate{evtl. auch weg lassen}
		\item Abspeichern von Pfaden
		\item Abfahren von Pfaden
	\end{itemize}
	\item Module werden im Folgenden kurz beschrieben
	\item Kollisionsvermeidung als eigener Abschnitt
\end{itemize}

\missingfigure[figwidth=0.7\textwidth]{Behaviours}


\subsubsection{Position des Menschen}

\begin{itemize}
    \item bekommt aktuelle Position und Geschwindigkeit des Menschen von Kinect
    \item schätzt die zukünftige Position des Menschen anhand dieser Daten
    \item gibt aktuelle und geschätzte Position des Menschen aus
    \item Zeit-Parameter für die Schätzung: $t_{est}$
    \item Berechnung nach der Formel: $s_{est} = s_{act} + v \cdot t_{est}$
\end{itemize}


\subsubsection{Berechnung der Trajektorie}

\begin{itemize}
	\item Struktur der zu berechnenden Trajektorie duch \lstinline{OmniDriveAlongPath} \todoprivate{ref zu LowLevel?}\ vorgegeben:
	\begin{itemize}
		\item Start $(x,y)$, Koordinaten
		\item Following $(x,y,yaw)$, Koordinaten und Orientierung \todoprivate{Skizze zu x-y-z-roll-pitch-yaw ?}
		\item Next $(x,y)$, Koordinaten
	\end{itemize}
	\item Modul bekommt aktuelle und geschätzte Position des Menschen, sowie aktuelle Position des Roboters
	\item Berechnung einer neuen Trajektorie, sobald neue Mensch-Daten vorliegen
	\item Berechnung der Trajektorien-Punkte im Einzelnen:
	\begin{itemize}
	  \item Start: aktuelle Roboterposition
	  \item Next: Pose auf Roboter-Mensch-Vektor, die sich im Abstand $d$ vor dem Mensch befindet; yaw wird gesondert berechnet, sodass Roboter immer zu Mensch schaut
	  \item Following: Position auf next-estimated-Vektor, die sich $d$ vor geschätzter Mensch-Position befindet
	  \item erfolgt alles in absoluten Weltkoordinaten
  \end{itemize}
  \item Parameter $d$ für den Abstand des Roboters zum Menschen, default: $2m$
  \item Berechnung des yaw-Wertes: \todoprivate{Formel dazu}

% 	\item MUX für Trajektorie
% 	\begin{itemize}
% 		\item GenerateTrajectory
% 		\item LoadFromFile
% 	\end{itemize}
\end{itemize}

\todoprivate{Zeichnung mit Vektoren}



\subsubsection{Pfadspeichern und -laden}

\begin{itemize}
  \item Im \lstinline{followPerson} -Zustand: Wegpunkte $(x,y,yaw)$ werden in gewissen Abständen $d_{save}$ gespeichert
  \begin{itemize}
    \item sobald $ \overline{ s_{act} - s_{last} } > d_{save} $ \todoprivate{Fehler im Code??? Euklidischer Abstand stattdessen verwenden?}
  \end{itemize}
	\item Im \lstinline{loadPath} -Zustand: Nächster Wegpunkt wird geladen, sobald vorheriger erreicht wurde
  \begin{itemize}
		\item Im \lstinline{returnHome} -Zustand: Nächster Wegpunkt wird geladen, sobald vorheriger erreicht wurde; umgekehrte Reihenfolge
    \item sobald $ d( s_{foll} - s_{act} ) > d( s_{nxt} - s_{act} ) $, Euklidischer Abstand
  	\item \lstinline{yaw} wird unabhängig von Datei berechnet, sodass Roboter immer Menschen anschaut
  \end{itemize}
  \item Eigene Klasse zum File-Handling: \lstinline{fileUtil}
  \begin{itemize}
    \item Mehrere dump-files möglich
    \item Auslesen der Wegpunkte in normaler und umgekehrter Reihenfolge
  \end{itemize}
\end{itemize}



% 
% % -----------------------------------------------------------------------------
% %													Transformationen
% \subsection{Transformationen}
% \label{transformationen_subsec}
% 
% \authorsection{\editorjulian}
% \todo[inline]{Julian: Sollen wir (also du ;-) ) noch so einen Abschnitt machen?}


% -----------------------------------------------------------------------------
%													Kollisionsvermeidung
\subsection{Kollisionsvermeidung}
\label{kollisionsvermeidung_subsec}

\subsubsection{Modul}
\authorsection{\editortobias}
\todo[inline]{Tobi: Schreiben}

\begin{itemize}
 
  \item Kollisionsvermeidungsmodul (\lstinline{ObstacleAvoidance}) überprüft die geplante Trajektorie auf Hindernisse, und plant ggf. um Hindernisse
  \item Ausgaben von \lstinline{GenerateTrajectory} und \lstinline{LoadFromFile} werden geMUXt
  \begin{itemize}
    \item je nach Modus (\lstinline{followPerson} bzw. \lstinline{returnHome} / \lstinline{followPath}) schaltet MUX andere Eingänge durch
  	\item Die Ausgabe des MUX wird dann widerum komplett durch das Kollisionsvermeidungsmodul (\lstinline{ObstacleAvoidance}) geschleift
    \item Dadurch wird jede Trajektorie auf Hindernisse überprüft, keine kommt \glqq daran vorbei\grqq
  \end{itemize}
  \item Innerhalb des Moduls wird jede Trajektorie auf Hindernisse überprüft
	\begin{itemize}
	  \item die (Bild-)Punkte zwischen start, next und following werden berechnet (Transformation der Welt- in Bildkoordinaten)
	  \item Überprüfung für jeden einzelnen Punkt, ob er innerhalb eines Hindernisses liegt
	  \item Verwendung der \lstinline{ObstacleMap} \todoprivate{ref zu Lokalisierung}
	\end{itemize}
  \item Ohne Hindernis werden Trajektorien-Punkte nur durchgeschleift
  \item Wenn Hindernis erkannt, dann wird eine neue Trajektorie ermittelt
  \begin{itemize}
    \item Verwendung des A*-Algorithmus
    \item Ermittlung des Start- und Endpunktes für A*
    \item ggf. gesonderte Behandlung für Endpunkt (\lstinline{choosePointAfterObstacle})
    \item Aufruf A*
    \item Transformation der nuen Trajektorie IK $\rightarrow$ WK
  \end{itemize}

\end{itemize}



\subsubsection{Algorithmen}
\authorsection{\editorjulian}
\todo[inline]{Julian: Schreiben}





% -----------------------------------------------------------------------------
%													Simulation
\subsection{Simulation}
\label{simulation_subsec}
\authorsection{\editoroier}
\todo[inline]{Oier: Schreiben}
